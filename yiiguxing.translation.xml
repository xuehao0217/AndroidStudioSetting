<application>
  <component name="AppStorage">
    <option name="newTranslationDialogHeight" value="316" />
    <option name="newTranslationDialogWidth" value="645" />
    <option name="newTranslationDialogX" value="459" />
    <option name="newTranslationDialogY" value="-655" />
    <histories>
      <item value="推荐" />
      <item value="Installation did not succeed. The application could not be installed." />
      <item value="0802 17:11:35: Launching 'app' on HUAWEI HMA-AL00. Retry Installation did not succeed. The application could not be installed. List of apks: [0] 'UsersxuehaoAndroidStudioProjectsworkandroid_platformappbuildoutputsapkdebugapp-debug.apk' Installation failed due to: 'Invalid File: UsersxuehaoAndroidStudioProjectsworkandroid_platformappbuildoutputsapkdebugapp-debug.apk'" />
      <item value="The following project options are deprecated and have been removed:" />
      <item value="渐变&#10;" />
      <item value="选中&#10;" />
      <item value="Glide treats LayoutParams.WRAP_CONTENT as a request for an image the size of this&quot; + &quot; device's screen dimensions. If you want to load the original image and are&quot; + &quot; ok with the corresponding memory cost and OOMs (depending on the input size),&quot; + &quot; use override(Target.SIZE_ORIGINAL). Otherwise, use LayoutParams.MATCH_PARENT,&quot; + &quot; set layout_width and layout_height to fixed dimension, or use .override()&quot; + &quot; with fixed dimensions." />
      <item value="Finally we consider the view valid if the layout parameter size is set to wrap_content. It's difficult for Glide to figure out what to do here. Although Target.SIZE_ORIGINAL is a coherent choice, it's extremely dangerous because original images may be much too large to fit in memory or so large that only a couple can fit in memory, causing OOMs. If users want the original image, they can always use .override(Target.SIZE_ORIGINAL). Since wrap_content may never resolve to a real size unless we load something, we aim for a square whose length is the largest screen size. That way we're loading something and that something has some hope of being downsampled to a size that the device can support. We also log a warning that tries to explain what Glide is doing and why some alternatives are preferable. Since WRAP_CONTENT is sometimes used as a default layout parameter, we always wait for layout to complete before using this fallback parameter (ConstraintLayout among others)." />
      <item value="Implementation of the {@link SnapHelper} supporting snapping in either vertical or horizontal orientation. &lt;p&gt; The implementation will snap the center of the target child view to the center of the attached {@link RecyclerView}. If you intend to change this behavior then override {@link SnapHelpercalculateDistanceToFinalSnap}." />
      <item value="calculate Distance To Final Snap" />
      <item value="translate" />
      <item value="The width of this side of the border, in logical pixels. Setting width to 0.0 will result in a hairline border. This means that the border will have the width of one physical pixel. Also, hairline rendering takes shortcuts when the path overlaps a pixel more than once. This means that it will render faster than otherwise, but it might double-hit pixels, giving it a slightly darkerlighter result. To omit the border entirely, set the [style] to [BorderStyle.none]." />
      <item value="If non-null, sets its width to the child's width multiplied by this factor. Can be both greater and less than 1.0 but must be non-negative." />
      <item value="Increasing the maximum heap size from 1280MB to 2048MB could make the IDE perform better, based on the available memory and your project size." />
      <item value="魔镜&#10;" />
      <item value="mo'jign" />
      <item value="@param l Left position, relative to parent @param t Top position, relative to parent @param r Right position, relative to parent @param b Bottom position, relative to parent" />
      <item value="报名&#10;" />
      <item value="体验官" />
      <item value="体验guan" />
      <item value="体验" />
      <item value="ti'yang" />
      <item value="Whether to paint the [shape] border in front of the [child]. The default value is true. If false, the border will be painted behind the [child]." />
      <item value="The following assertion was thrown building CommonListView2&lt;HomeDatas&gt;(dirty, state: _CommonListView2State6e314): Failed assertion: boolean expression must not be null" />
      <item value="satety" />
      <item value="satet" />
      <item value="sate" />
      <item value="sat" />
      <item value="st" />
      <item value="s" />
      <item value="The following assertion was thrown building CommonListView&lt;String&gt;(dirty): setState() or markNeedsBuild() called during build. This HomePage widget cannot be marked as needing to build because the framework is already in the process of building widgets. A widget can be marked as needing to be built during the build phase only if one of its ancestors is currently building. This exception is allowed because the framework builds parent widgets before children, which means a dirty descendant will always be built. Otherwise, the framework might not visit this widget during this build phase. The widget on which setState() or markNeedsBuild() was called was: HomePage state: _HomePageStatee90f3 The widget which was currently being built when the offending call was made was: CommonListView&lt;String&gt; dirty" />
      <item value="The following assertion was thrown building CommonListView&lt;String&gt;(dirty): setState() or markNeedsBuild() called during build. This Overlay widget cannot be marked as needing to build because the framework is already in the process of building widgets. A widget can be marked as needing to be built during the build phase only if one of its ancestors is currently building. This exception is allowed because the framework builds parent widgets before children, which means a dirty descendant will always be built. Otherwise, the framework might not visit this widget during this build phase. The widget on which setState() or markNeedsBuild() was called was: Overlay state: OverlayState83e52(entries: [OverlayEntry82716(opaque: false; maintainState: false), OverlayEntry3ed9c(opaque: false; maintainState: false)]) The widget which was currently being built when the offending call was made was: CommonListView&lt;String&gt; dirty The relevant error-causing widget was" />
      <item value="This Overlay widget cannot be marked as needing to build because the framework is already in the process of building widgets. A widget can be marked as needing to be built during the build phase only if one of its ancestors is currently building. This exception is allowed because the framework builds parent widgets before children, which means a dirty descendant will always be built. Otherwise, the framework might not visit this widget during this build phase. The widget on which setState() or markNeedsBuild() was called was: Overlay state: OverlayState83e52(entries: [OverlayEntry82716(opaque: false; maintainState: false), OverlayEntry3ed9c(opaque: false; maintainState: false)]) The widget which was currently being built when the offending call was made was: CommonListView&lt;String&gt; dirty" />
      <item value="组件&#10;" />
      <item value="多条目&#10;&#10;" />
      <item value="多ti'o'a'mu&#10;" />
      <item value="多tioa'm'y&#10;" />
      <item value="多条mu&#10;" />
      <item value="多条&#10;" />
      <item value="多tioa'm" />
      <item value="多跳" />
      <item value="多" />
      <item value="多条目&#10;" />
      <item value="多&#10;" />
      <item value="多条" />
      <item value="libTest.dart: Warning: Interpreting this as package URI, 'package:flutter_common_libTest.dart'." />
      <item value="Warning: Interpreting this as package URI" />
      <item value="The following assertion was thrown building Builder(dirty): setState() or markNeedsBuild() called during build." />
      <item value="setState() or markNeedsBuild() called during build." />
      <item value="callback when header refresh when the callback is happening,you should use [RefreshController] to end refreshing state,else it will keep refreshing state" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="172" />
        <entry key="ENGLISH" value="173" />
        <entry key="CHINESE_TRADITIONAL" value="3" />
        <entry key="ALBANIAN" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1627895512855" />
  </component>
</application>