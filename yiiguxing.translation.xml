<application>
  <component name="AppStorage">
    <option name="newTranslationDialogHeight" value="316" />
    <option name="newTranslationDialogWidth" value="645" />
    <option name="newTranslationDialogX" value="291" />
    <option name="newTranslationDialogY" value="279" />
    <option name="pinNewTranslationDialog" value="true" />
    <histories>
      <item value="Parameter specified as non-null is null: method kotlin.jvm.internal.Intrinsics.checkNotNullParameter, parameter entity" />
      <item value="Sets whether this bottom sheet can hide when it is swiped down. Params: hideable – true to make this bottom sheet hideable." />
      <item value="Illegal state argument: 5" />
      <item value="Universal Activity" />
      <item value="java.lang.IllegalStateException: The application's PagerAdapter changed the adapter's contents without calling PagerAdapter#notifyDataSetChanged! Expected adapter item count: 7, found: 0 Pager id: com.youxiang.soyoungapp:id/viewPager Pager class: class androidx.viewpager.widget.ViewPager Problematic adapter: class com.soyoung.module_doc.map.SearchMapHosPageAdapter" />
      <item value="The bottom sheet is settling." />
      <item value="Sets the height of the bottom sheet when it is collapsed. Params: peekHeight – The height of the collapsed bottom sheet in pixels, or PEEK_HEIGHT_AUTO to configure the sheet to peek automatically at 16:9 ratio keyline." />
      <item value="Multiplies this value by the other value." />
      <item value="Push was canceled, because there were conflicts during the update. Check that conflicts were resolved correctly, and invoke push again." />
      <item value="开关" />
      <item value="k" />
      <item value="Gold" />
      <item value="This type is final, so it cannot be inherited from" />
      <item value="Type mismatch: inferred type is SyTextView but Context was expected" />
      <item value="Details" />
      <item value="Feature" />
      <item value="d Feature Details" />
      <item value="推荐" />
      <item value="推荐妆容" />
      <item value="tjui'jian" />
      <item value="数据" />
      <item value="关键" />
      <item value="guan" />
      <item value="颜值" />
      <item value="yan'zhi" />
      <item value="重点" />
      <item value="zhong" />
      <item value="zhong'fu'a'b" />
      <item value="zhon" />
      <item value="重点&#10;" />
      <item value="组件" />
      <item value="控件" />
      <item value="weight" />
      <item value="wei" />
      <item value="w" />
      <item value="wi" />
      <item value="组件&#10;" />
      <item value="The bottom sheet is collapsed." />
      <item value="STATE COLLAPSED" />
      <item value="Manifest merger failed : Attribute meta-datacom.amap.api.v2.apikey@value at AndroidManifest.xml:167:9-169:46 requires a placeholder substitution but no value for &lt;amap_apikey&gt; is provided." />
      <item value="地址" />
      <item value="dizh9i" />
      <item value="Returns the position of the ViewHolder in terms of the latest layout pass. This position is mostly used by RecyclerView components to be consistent while RecyclerView lazily processes adapter updates. For performance and animation reasons, RecyclerView batches all adapter updates until the next layout pass. This may cause mismatches between the Adapter position of the item and the position it had in the latest layout calculations. LayoutManagers should always call this method while doing calculations based on item positions. All methods in RecyclerView.LayoutManager, RecyclerView.State, RecyclerView.Recycler that receive a position expect it to be the layout position of the item. If LayoutManager needs to call an external method that requires the adapter position of the item, it can use getAbsoluteAdapterPosition() or RecyclerView.Recycler.convertPreLayoutPositionToPostLayout(int). Returns: Returns the adapter position of the ViewHolder in the latest layout pass. See Also: getBindingAdapterPosition(), getAbsoluteAdapterPosition()" />
      <item value="This method is confusing when adapters nest other adapters. If you are calling this in the context of an Adapter, you probably want to call getBindingAdapterPosition() or if you want the position as RecyclerView sees it, you should call getAbsoluteAdapterPosition(). Returns: getBindingAdapterPosition()" />
      <item value="There is no generic of ViewBinding." />
      <item value="How to modify the base adapter class to use view binding, you need the following steps: 1. Adds a generic of view binding to the base class. 2. Uses a class of view holder with binding instead of the class of original view holder. 3. Overrides the method of creating view holder and returns the view holder by the [inflateBindingWithGeneric] method. 4. It is recommended to override the method for binding view holder so that it is simpler to use. Here is the core code. If you use `BaseRecyclerViewAdapterHelper`, you can copy this file directly to use. @author Dylan Cai" />
      <item value="java.lang.Runtime Exception" />
      <item value="java.lang.reflect.InvocationTargetException at com.android.internal.os.RuntimeInitMethodAndArgsCaller.run(RuntimeInit.java:523)" />
      <item value="Base Real Visible Util" />
      <item value="Cannot access 'android.viewbinding.ViewBinding' which is a supertype of 'com.youxiang.library_face.databinding.LayoutAiMainResultFanganNewBinding'. Check your module classpath for missing or conflicting dependencies" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="966" />
        <entry key="ENGLISH" value="967" />
        <entry key="CHINESE_TRADITIONAL" value="3" />
        <entry key="ALBANIAN" value="1" />
        <entry key="ROMANIAN" value="1" />
        <entry key="SPANISH" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1645424745806" />
  </component>
</application>